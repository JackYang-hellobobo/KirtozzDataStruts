## 从有序的数组开始

_线性查找一个传统数组（乱序）最多需要多少步呢?_

><font size="2">如果要查找的值刚好在数组的最后一个格子里（比如"elderberries"），那么计算机就必须检查数组的每一个格子。如果数组种根本没有要找的值，那么计算机同样需要检查每一个格子，才能确定这个值不在数组中。</font>

* 所以对于有N个格子的传统乱序数组，线性查找最多需要N步。
  
_那么再考虑插入操作（可以理解成增添新值）_
   
><font size="2">~~众所周知，~~ 插入一个值到乱序数组的末尾只需要1步，插入到中间任意位置就需要在目标位置其后的所有元素往后挪格子，以腾出位置来在目标位置插入新值。但既然是乱序的数组，~~添值自然是随便插啦（肯定是插到末尾最省力）。~~ </font>

* 所以描述传统数组插入所需的步骤数时一般为1。
  
有序数组中的值是**按顺序**排列的，也就是说，插入新值时，这个值必须被放到一个合适的格子中，以免打乱数组的顺序。

||||||
|---|---|---|---|---|
| 3 | 17 | 80 | 202 | ? |

><font size="2">假设要插入值75，如果是传统数组，直接可以在末尾的 '?' 处插入75，这只需要1步。
>但这是有序的数组,别无选择，只能把75插到17和80之间，以保证数组仍然是有序的。插入步骤需要6步（比较3步，右移后面的数据2步，插入1步）</font>

可以看出，**向有序数组插值时，总需要插入前先查找正确的插入位置**。这就是有序数组和传统数组之间的性能差异之一。


---

_虽然有序数组的插入比传统数组慢，但其查找则另有玄机。_

#### 二分查找

小时候我们可能玩过一个猜数游戏：我心里想一个1和100之间的数字，由你来猜。我会告诉你，你的猜测是高了还是低了。 你可能凭借直觉就知道怎么猜——你肯定不会从1开始猜，而更可能从正中间的50开始。为什么呢？

* 因为无论是高还是低，你都能排除一半的错误选项。

><font size="2">如果你猜50，然后我说低了，那么你就可以猜75.这样又能从**剩下的数中去掉一半**。如果我这次告诉你高了，那么你就可以猜62或者63。你应该一直挑剩下数的中间值，来去掉一半选项。</font>

我们以猜1和10之间的数为例，用下图展示这个过程。

![Array1.png](/pictures/Array1.png "猜数游戏1~10的示例")

简单的来说，这就是[二分查找](https://github.com/kirtozz/DataStructuresAndAlgorithms/blob/master/SummaryOfAlgorithms.md)。

对于比较小的有序数组，_二分查找_ 相对于线性查找的优势并不大。
<font size="2">>对于最坏的情况——要查找的值在最后一个格子。   
>如果我有**3个**元素，_线性查找_ 最多需要**3步**，_二分查找_ 则最多需要**2步**。      
>如果我有**7个**元素，_线性查找_ 最多需要**7步**，_二分查找_ 则最多需要**3步**。   
>如果我有**15个**元素，_线性查找_ 最多需要**15步**，_二分查找_ 则最多需要**4步**。</font>

我们发现每次加倍有序数组大小，二分查找都只增加**1步**。因为每次查找都**排除一半元素**，所有这很合理。

对于更大的数组，有**10000个**元素的数组来说，线性查找最多需要10000步，而二分查找最多需要**13步**；对有**100万个**数组来说，线性查找最多需要100万步，但二分查找最多只需要**20步**！！！

![Array2.png](/pictures/Array2.png "线性查找和二分查找的性能差别")

上图展示了线性查找和二分查找的性能差别。

